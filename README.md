```
1.  Ответ вычисляется так:
задержка * пропускную способность канала = 300*1Гбит/с = 36621.1 KByte
так получается потому что полученное произведение необходимо поделить на 8 дабы получить KByte 
```
```
2.  Я высчитал в 4 и более раза. Завимость также есть от задержек, потому точнее ответить затрудняюсь. Информацию брал по диаграмме зависимости. 
```
```
3.  Для начала прикину накладные расходы одного кадра (Ethernet Header + Ethernet trailer + TCP + IP)
Итого: 14+4+20+20 =58 байт служебной информации. Если отнять от Ethrnet frame IP и TCP, то полезного объёма останется 6 и 1460 соответственно.
Получается такая схема:
            Минимально   Максимально
      общая  64          1518 
   полезная  6           1460
  служебная  58          58
 % полезной  9,37%       96,18%
 Вывод : размер фрейма влияет на передачу данных.
 ```
```
4. Будет выглядеть примерно так: 
а. Поиск IP по имени 
   - поиск в КЭШЕ соответсвия имени хоста/ также файле hosts ( по условиям задачи отсутствует)
   - Запрос ARP на ДНС, если в КЭШ ДНС IP нет, то рекурсивный запрос, который проходит по списку вышестоящих DNS-серверов.
   - Запрос на корневой ДНС  перенаправление  на top level domain -> .ru.
   - Запрос на top level domain .ru  перенаправление на netology.ru
   - запрос на netology.ru возврашает IP
б. При получении IP-адреса конечного сервера, берётся также данные
   об используемом порте из URL (80 порт для HTTP, 443 для HTTPS)
   это происходит по системе "3-х рукопожатий":
   - FIN WAIT 1 (active close)   FIN->   CLOSE WAIT (passive close)
   - FIN WAIT 2                  <-ACK   CLOSE WAIT (passive close)
   - TIME WAIT                   <-FIN   LAST ACK
   - TIME WAIT                   ACK->   CLOSED   
```
```
5. 
```
```
6. Данная команда касается UDP порта. О чём говрит флаг -u.
time-wait - присуще tcp, такак это состояние когда порт отправил подтверждение о завершении соединения и ожидает ответа, чего udp не делает. Значит и в состояние такое не придёт.
unconn - состояние аналогичное tcp listenning, т.е порт открыт, но в силу особенностей протокола, будет отображаться как состояние не известно. Подключения на такой порт будут проходить.
```
```
7. Схема будет выглядеть так:
                   Client                 Server 
                 ESTABLESHED             ESTABLESHED
1.  FIN WAIT 1 (active close)   FIN->   CLOSE WAIT (passive close)
2.  FIN WAIT 2                  <-ACK   CLOSE WAIT (passive close)
3.  TIME WAIT                   <-FIN   LAST ACK
4.  TIME WAIT                   ACK->   CLOSED
                  CLOSED                CLOSED

```
```
8. Теоретическое кол-во соединений  2^16=65536.
Используются 0-65535, порт из всех бинарных единиц, т.е. 65536 не используется
Поэтому чило на 1 клиента 65535
Если клиентов больше одного, то в теории (кол-во клиентов) * (кол-во портов клиента (65536))  
```
```
9. Да, такая ситуация возможна. Возникает при активном подключении и отключении клиента к удаленной службе.
Предположу что большое число соединений time-wait 
имеет негативный характер. Поскольку оба IP и удаленный порт остаются неизменными,
то на каждое новое соединение выделяется новый локальный порт. Если клиент был активной
стороной завершения TCP-сессии, то это соединение будет заблокировано какое-то время в состоянии TIME_WAIT.
Если соединения устанавливаются быстрее чем порты выходят из карантина, то это в теории может быть причиной
ошибки в соединении.
Даже если приложения обращаются к разным службам, и ошибка не происходит, очередь TIME_WAIT будет расти,
используя системные ресурсы.

```
```
10. Проблема с фрагментацией пакетов например возникает в SIP телефонии. Если по каким-то причинам фрагмент 
не дойдёт, в случае TCP, вопрос решается повторной отправкой. В UPD пакет попросту будет потерян.
  
```
```
11. Мой выбор за TCP по причине гарантированной доставки пакетов.
Syslog начинал с UDP, в более свежих его реализациях присутсвует поддержка TCP/
Причины мне кажется очевидны.

```
```
12. Ответ:
ss state listening -t -p -s
Total: 131
TCP:   6 (estab 1, closed 0, orphaned 0, timewait 0)

Transport Total     IP        IPv6
RAW       1         0         1
UDP       4         3         1
TCP       6         4         2
INET      11        7         4
FRAG      0         0         0

Recv-Q  Send-Q   Local Address:Port       Peer Address:Port  Process                                                    
0       4096           0.0.0.0:sunrpc          0.0.0.0:*      users:(("rpcbind",pid=592,fd=4),("systemd",pid=1,fd=35))  
0       4096     127.0.0.53%lo:domain          0.0.0.0:*      users:(("systemd-resolve",pid=593,fd=13))                 
0       128            0.0.0.0:ssh             0.0.0.0:*      users:(("sshd",pid=1169,fd=3))                            
0       4096              [::]:sunrpc             [::]:*      users:(("rpcbind",pid=592,fd=6),("systemd",pid=1,fd=37))  
0       128               [::]:ssh                [::]:*      users:(("sshd",pid=1169,fd=4))
Как видно 6 TCP - 4 IPv4 и 2 IPv6
Процессы: systemd,sshd                 
```
```
13. 
1. tcpdump -A -c 1
где ключ -A и отвечает за вывод в тексте
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
15:51:52.683395 IP vagrant.ssh > _gateway.57392: Flags [P.], seq 3426544232:3426544332, ack 34123123, win 62780, length 100
E...~.@.@...
...
......0.<.h...sP..<....Q.+*..6..%....CIe".{.W.........m....
..5GH.*..+_-.~<r'k.....\......0..e>Q...-I.|?[.U...W.nO.U.).r.lZ
1 packet captured
34 packets received by filter
1 packet dropped by kernel
2. sudo tcpdump -x -c 1
-x - позволит увидеть данные в HEX формате
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
15:58:25.884633 IP vagrant.ssh > _gateway.57392: Flags [P.], seq 3426545316:3426545352, ack 34123203, win 62780, length 36
        0x0000:  4510 004c 7ecb 4000 4006 a3c0 0a00 020f
        0x0010:  0a00 0202 0016 e030 cc3c eea4 0208 adc3
        0x0020:  5018 f53c 184f 0000 f65f ff5c c60d 7dca
        0x0030:  c7b0 a0b0 b967 ad76 74ae 59d1 f1fd 81cd
        0x0040:  ebfa fc21 74d4 afa4 e1c6 1d81
1 packet captured
50 packets received by filter
18 packets dropped by kernel

```
```
14. Флаг IP будет отображаться в таком виде
 Flags: 0x40, Don't fragment
        0... .... = Reserved bit: Not set   - всегда 0, т.к. зарезервировано
        .1.. .... = Don't fragment: Set   - если 1 то не фрагментирован, при 0 наоборот
        ..0. .... = More fragments: Not set  - 0 означает что фрагмент последний, 1 - есть ещё фрагмент

Ethernet будет называться Ethernet II
Organizationally Unique Identifier можно увидеть например в таком виде  -  12:35:02 (52:54:00:12:35:02)
```
